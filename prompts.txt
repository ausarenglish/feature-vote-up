Write each prompt I send to you into a file prompts.txt, so I can audit the work.

Create a minimal backend under /server and wire the frontend client.

Files:
- /server/index.js  (Node + Express)
- /server/db.js     (better-sqlite3 wrapper)
- /server/schema.sql

DB:
- SQLite file at /server/data.sqlite
- Table features (
    id INTEGER PRIMARY KEY,
    title TEXT NOT NULL,
    votes INTEGER NOT NULL DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
  )

Server:
- app.use(cors()) and app.use(express.json())
- On boot, ensure schema exists (run schema.sql if table missing)
- Endpoints:
  GET  /features                    -> rows sorted by votes DESC, created_at DESC
  POST /features {title}            -> insert, return row
  POST /features/:id/upvote         -> increment votes, return row
- Basic error handler returning JSON { error } with status codes

Frontend client:
- Create /src/lib/api.ts with getFeatures(), createFeature(title), upvoteFeature(id).
- const base = import.meta.env.VITE_API_URL
- Home loads getFeatures() on mount; New posts then navigates home.
- Upvote is optimistic and rolls back on failure.

package.json scripts:
- "server": "node server/index.js"
- "server:watch": "nodemon server/index.js"

Also add .env.example with:
VITE_API_URL=http://localhost:4000

Update README with backend run steps.

Update the backend to run correctly with "type": "module" in package.json.

- Convert /server/index.js and /server/db.js to ESM imports:
  * Replace all `const X = require(...)` with `import ... from '...'`
  * Use `export default` or named exports where appropriate.
- Ensure /server/schema.sql stays the same.
- Update any module.exports usage to ES export syntax.
- Keep all functionality the same: Express server, CORS, JSON middleware, better-sqlite3 for the DB, endpoints for /features and /features/:id/upvote.

Also, in package.json:
- Ensure "server": "node server/index.js" works under ESM.
- Keep "server:watch": "nodemon server/index.js".

Do not rename to .cjs — keep .js and use proper ESM imports/exports instead.

Scan the repo and show me a concise tree of src/, key pages/components, and where features list, add form, and settings live. Don't change anything yet. Identify the component(s) that render:
1) the features list and vote button,
2) the add/new feature form,
3) the empty state if any,
4) the main layout/shell.

Do a lightweight visual polish without changing behavior:
- Ensure a consistent spacing scale (use Tailwind 4/6/8/12/16 etc). 
- Make the page title clearly styled (semibold, sensible size).
- Give feature cards a subtle shadow and consistent rounded corners.
- Ensure primary buttons (add / upvote) have min-h-[44px] and px-4 py-2.
- Use one accent color (keep current blue if present) and neutral grays for text.
Edit only the files that render the main list and its cards. Show diffs.
Then run: npm run dev and confirm the page renders at http://localhost:8080

Add a simple loading state while features are fetched:
- Create a FeatureListSkeleton with 3 gray "card" rows using Tailwind animate-pulse.
- Show it whenever the list query is loading or we have no data yet but are fetching.
Place the skeleton near the list component and wire it in. Show diffs and how you detect loading.

Add a friendly empty state when there are zero features and not loading:
- Big title "No features yet"
- Sub text "Be the first to suggest one."
- A button to open the "New Feature" form.
Create a tiny EmptyState.tsx component and use it in the list container. Show diffs.

Improve tap feedback on the vote button:
- Add a quick scale/shine animation on click (CSS class + 120ms transition).
- Try navigator.vibrate?.(10) for web; guard so it never throws.
- Expose a small helper useHaptic() that calls vibrate on web and is a no-op elsewhere.
Apply it to the vote button only. Show diffs.

Add a simple sort toggle aligned to the right of the list header:
- Two pills: "Top" (default) and "Newest".
- Sorting is client-side: Top = votes desc, Newest = created_at desc.
Do not change the API. Keep state locally in the list container and memoize the sorted array.
Show diffs and confirm both modes work.

Make sure the page respects the iOS safe area so the floating + button and bottom content never collide with the indicator:
- Add a CSS utility (globals.css or index.css) for .safe-bottom { padding-bottom: max(env(safe-area-inset-bottom), 16px); }
- Apply safe-bottom to the outer page container.
Show diffs.

Ensure interactive elements have accessible names and focus states:
- Vote button: aria-label="Upvote <feature title>" and visible focus ring.
- Add button: aria-label="Add feature".
- List headings use semantic <h1>/<h2>.
Show diffs.

Run the production build and copy to iOS:
npm run build
npx cap copy ios
Confirm the copy succeeded and remind me to press Run in Xcode (workspace already open).

You are working inside my `feature-vote-up` project.  
I need you to add **tiny polling + focus refresh** to keep the feature list in sync across web and iOS.  

Steps:  
1. Open the component that renders the list of features (likely `src/components/FeatureList.tsx` or equivalent).  
2. Add a `fetchFeatures` function that:  
   - Fetches `${import.meta.env.VITE_API_URL}/features`  
   - Uses `cache: "no-store"`  
   - Cancels in-flight requests with an `AbortController`.  
   - Updates local state.  
3. Add a `refetch` wrapper and call it:  
   - Immediately on mount  
   - Every 3 seconds with `setInterval`  
   - On `window.focus` and `document.visibilitychange` (web)  
   - On iOS app foreground via Capacitor's `App.addListener("appStateChange")`.  
4. After a successful upvote or new feature submission, call `refetch()` to align with server state.  
5. Clean up all intervals and listeners on unmount.  

Make sure polling works on web **and** iOS simulator without errors if Capacitor isn't available. Guard the `App.addListener` import so it's safe on web.  

Insert the code in a way that is copy-paste runnable with minimal changes.  
Do not break optimistic updates — keep them, then immediately refetch from the server to resolve conflicts.